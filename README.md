`Footnotes` : 

`1` - `Black Hat Python by Justin Seitz`

`2` - `https://github.com/EONRaider/blackhat-python3`
## ðð²ð­ð¡ð¨ð§ ðŸð¨ð« ð©ðžð§-ð­ðžð¬ð­ð¢ð§ð 
## ð’ðžð­ð­ð¢ð§ð  ð®ð©

- Check python version:
  - `python3 --version` 

```
â”Œâ”€â”€(shreyasã‰¿kali)-[~/python]
â””â”€$ python3 --version
Python 3.9.9

```
- Install package managers
  - `sudo apt install python-setuptools python3-pip`
  - `pip install github3.py ` 

```
â”Œâ”€â”€(shreyasã‰¿kali)-[~/python]
â””â”€$ sudo apt install python-setuptools python3-pip                                        100 â¨¯
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  python-pip-whl python-pkg-resources python3-wheel

.
.
.
```

```
                                                                                                
â”Œâ”€â”€(shreyasã‰¿kali)-[~/python]
â””â”€$ pip install github3.py                                                                130 â¨¯
Collecting github3.py
  Downloading github3.py-3.0.0-py2.py3-none-any.whl (148 kB)
     |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 148 kB 126 kB/s 
Collecting jwcrypto>=0.5.0
  Downloading jwcrypto-1.0-py2.py3-none-any.whl (82 kB)
     |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 82 kB 108 kB/s 
Collecting uritemplate>=3.0.0
  Downloading uritemplate-4.1.1-py2.py3-none-any.whl (10 kB)
Requirement already satisfied: python-dateutil>=2.6.0 in /usr/lib/python3/dist-packages (from github3.py) (2.8.1)
Requirement already satisfied: requests>=2.18 in /usr/lib/python3/dist-packages (from github3.py) (2.25.1)
Requirement already satisfied: cryptogr
.
.
.
```


## ððžð­ð°ð¨ð«ð¤

- `socket` is the most important module.


### ð“ð‚ð ð‚ð¥ð¢ðžð§ð­
- When to use?
>  If you are working within the confines of large enterprise environments, you wonâ€™t have the luxury of networking tools or compilers, and sometimes youâ€™ll even be missing the absolute basics like the ability to copy/paste or an Internet connection. This is where being able to quickly create a TCP client comes in extremely handy. 

```
import socket

target_host = "www.google.com"
target_port = 80

# create a socket object
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# connect the client
client.connect((target_host, target_port))

# send some data
client.send(b"GET / HTTP/1.1\r\nHost:www.google.com\r\n\r\n")

# receive data
response = client.recv(4096)

client.close()

print(response)

```

- `client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`
> - `AF_INET` means standard ipv4 address or hostname is going to be used
> - `SOCK_STREAM` indicates this will be a TCP Client

---

### ð”ðƒð ð‚ð¥ð¢ðžð§ð­

```
import socket

target_host = "127.0.0.1"
target_port = 80


# create a socket object
client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# send some data
client.sendto(b"randomsomething", (target_host, target_port))

# recieve some data
data, addrss = client.recvfrom(4096)

client.close()

print(data)

```
- `client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)`
> - `AF_INET` means standard ipv4 address or hostname is going to be used
> - `SOCK_DGRAM` indicates this will be a UDP client

---

### ð‘ðžð©ð¥ðšðœð¢ð§ð  ððžð­ðœðšð­

> On many occasions you will notice that netcat is not installed on a server but python is. In these cases, itâ€™s useful to create a simple network client and server that you can use to push files, or a listener that gives you command line access. If youâ€™ve broken in through a web application, itâ€™s definitely worth dropping a Python callback to give you secondary access without having to first burn one of your trojans or backdoors


### ð“ð‚ð ðð«ð¨ð±ð²

> When performing penetration tests in enterprise environments, you probably wonâ€™t be able to run Wireshark; nor will you be able to load drivers to sniff the loopback on Windows, and network segmentation will prevent you from running your tools directly against your target host. We can build simple Python proxies, in various cases to help us understand unknown protocols, modify traffic being sent to an application, and create test cases for fuzzers. 

### ð’ð’ð‡ ð°ð¢ð­ð¡ ð©ðšð«ðšð¦ð¢ð¤ð¨

> What if your target doesnâ€™t have an SSH client, just like 99.81943 percent of Windows systems? and what if we wanna encrypt our traffic to avoid detection. That's when we use ssh python script

### 
